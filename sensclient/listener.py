import threading, time, sys
from tinyos3 import tos
    
    
# Define the listener types
T_DUMMY     = 0 # Listener type for generating dummy events
T_SERIAL    = 1 # Listener type for generic serial devices
T_TINYOS    = 2 # Listener type for TinyOS specific devices
T_BLUETOOTH = 3 # Listener type for bluetooth devices


def create_listener(ltype, **kwargs):
    '''
    Defines a factory function for creating device listeners.
    '''
    callback = kwargs['callback']
    device = kwargs['device']
    if ltype == T_DUMMY:
        return DummyListener(callback, 
                                device)
    elif ltype == T_SERIAL:
        return SerialListener(callback, 
                                device,
                                kwargs['baudrate'])
    elif ltype == T_TINYOS:
        return TinyOSListener(callback, 
                                device, 
                                kwargs['baudrate'], 
                                kwargs['amrate'])
    elif ltype == T_BLUETOOTH:
        return BluetoothListener(callback, 
                                device)


class _Listener(threading.Thread):
    '''
    -----------------------------------------------------------------
    IMPORTANT: While this class can be instantiated it will not do
    any actual listening. This class serves as a base class for other
    listeners. 

    When implementing a listener, override the listen() method to
    provide an implementation for listening for events. The run
    method defined by this class will handle the rest.
    
    Note that the data generated by events should be passed back
    from the listen() method in JSON format.
    -----------------------------------------------------------------
    
    Defines a class for listening for events on connected serial
    devices compatible with TinyOS. A single Listener is always
    bound to a single physical device.

    This class functions as state machine that runs as a daemon
    (background) thread.

    The state machine defines the following three states:
        PAUSED: Daemon alive, not reporting data.
        RUNNING: Daemon alive, reporting data.
        STOPPED: Daemon soon to be officially dead.
    In PAUSED mode, the state machine functions effectively as a
    spin lock. It will not collect data from the connected device
    and will not relay said data through the Listeners callback
    function.

    When created, a Listener will always intialize to the PAUSED
    state. Once stopped, the daemon thread backing the Listener
    cannot be restarted.
    '''

    # Define the states for the state machine
    PAUSED  = 0     # Listener is running, not reporting events
    RUNNING = 1     # Listener is running, reporting events
    STOPPED = 2     # Listener is not running


    def __init__(self, callback, device, baudrate, ltype):
        '''
        Returns a new instance of a Listener.
        Arguments:
            callback: The callback to execute when an event is
            received. The callback function should be thread-safe.
            device: The physical address of the device.
            baudrate: The sampling rate of the physical device.
            ltype: The type for the listener.
        '''
        threading.Thread.__init__(self, daemon=True)
        self._callback = threading.local()
        self._callback = callback

        self._device = threading.local()
        self._device = device

        self._baudrate = threading.local()
        self._baudrate = baudrate
        
        self._ltype = threading.local()
        self._ltype = ltype

        self._state = threading.local()
        self._state = Listener.PAUSED


    #
    # ACCESSOR METHODS
    #

    def baudrate(self):
        '''
        Gets the physical sampling rate of the device.
        '''
        return self._baudrate


    def device(self):
        '''
        Gets the physical address of the device being listened to.
        '''
        return self._device
        
        
    def listener_type(self):
        '''
        Gets the type of device the listener is listening on.
        '''
        return self._ltype


    def state(self):
        '''
        Gets the state that the Listener is in.
        '''
        return self._state


    def state_as_str(self):
        if self._state == Listener.RUNNING:
            return 'RUNNING'
        elif self._state == Listener.PAUSED:
            return 'PAUSED'
        elif self._state == Listener.STOPPED:
            return 'STOPPED'
        else:
            return 'NULL'


    #
    # CONTROL METHODS
    #
    
    def listen(self):
        '''
        Defines a method for overriding  
        '''
        pass


    def run(self):
        '''
        Overridden from the Thread superclass. This function defines
        the logic of the Listeners state machine.
        '''
        # Note that the tinyos specific code comes from the
        #   oscilloscope python application that ships with tos
        am = tos.AM()

        while self._state != Listener.STOPPED:
            if self._state != Listener.PAUSED:
                # call the listen method to get data from the device
                callback(listen())
                
            elif self._state == Listener.PAUSED:
                time.sleep(0)


    def resume(self):
        '''
        Provides a method for resuming the listener, thereby
        continuing data collection.
        '''
        if self.is_alive() and self._state == Listener.PAUSED:
            self._state = Listener.RUNNING


    def pause(self):
        '''
        Provides a method for pausing the Listener, thereby halting
        data collection.
        '''
        if self.is_alive() and self._state == Listener.RUNNING:
            self._state = Listener.PAUSED


    def stop(self):
        '''
        Provides a method for stopping the Listener, thereby ending
        the backing daemon thread.
        '''
        if self.is_alive() and self._state != Listener.STOPPED:
            self._state = Listener.STOPPED
            
           
class BluetoothListener(_Listener):
    '''
    Implements a wireless listener that reads in data from a
    connected bluetooth device.
    '''
    

    def __init__(self, callback, device):
        '''
        Returns an instance of the BluetoothListener class.
        Arguments:
            callback: The callback function to execute when data
            is read.
            device: The device mountpoint/endpoint.
        '''
        super().__init__(self, callback, device, 0, ltype=T_BLUETOOTH)
            
            
    def listen(self):
        # Implement reading from a bluetooth device
        pass
           
            
class DummyListener(_Listener):
    '''
    Implements a dummy listener that returns random data to the
    listening client.
    '''
    
    from random import random

    def __init__(self, callback, device):
        '''
        Returns an instance of the DummyListener class.
        Arguments:
            callback: The callback function to execute when data
            is read.
            device: The device mountpoint/endpoint.
            baudrate: The baudrate of the serial connection.
        '''
        super().__init__(callback, device, 0, ltype=T_DUMMY)
        

    def listen(self):
        '''
        Returns a random number in the range [0, 1) to the callback
        function.
        '''
        return random()
            
            
class SerialListener(_Listener):
    '''
    Implements a serial listener that returns data read in from
    a connected serial device.
    '''

    def __init__(self, callback, device, baudrate):
        '''
        Returns an instance of the SerialListener class.
        Arguments:
            callback: The callback function to execute when data
            is read.
            device: The device mountpoint/endpoint.
            baudrate: The baudrate of the serial connection.
        '''
        # Initialize the parent
        super().__init__(self, callback, device, baudrate, ltype=T_SERIAL)
        
        
    def listen(self):
        # TODO: Implement listening over the serial interface
        pass
        
        
class TinyOSListener(_Listener):
    '''
    Implements a serial listener that returns data read in from
    a connected TinyOS serial device.
    '''
            
    from tos import am
    
    #
    # DECLARE ANY TINYOS PACKET TYPES HERE
    #

    class OscilloscopePkt(tos.Packet):
        '''
        Defines a packet type for the Oscilloscope TinyOS application.
        
        This code comes from the 'oscilloscope.py' file in the TinyOS
        distribution.
        '''
        def __init__(self, packet=None):
            tinyos3.tos.Packet.__init__(self,
                [('version',  'int', 2),
                 ('interval', 'int', 2),
                 ('id',       'int', 2),
                 ('count',    'int', 2),
                 ('readings', 'blob', None)],
                packet)
    
    
    # The rate at which the AM module is configured to send
    #   messages. This is application specific so only
    #   the rate for the Oscilloscope application is defined
    AM_RATES = {
        'OSCIILLOSCOPE': 0x93
    }


    # Define baudrates for official TinyOS devices
    RATES = {
        'TELOS':        115200,
        'TELOSB':       115200,
        'TMOTE':        115200,
        'MICAZ':        57600,
        'MICA2':        57600,
        'IRIS':         57600,
        'MICA2DOT':     19200,
        'EYES':         115200,
        'INTELMOTE2':   115200
    }
    
    def __init__(self, callback, device, baudrate, amrate, 
            pkt_type=OscilloscopePkt):
        '''
        Returns an instance of the TinyOSListener class.
        Arguments:
            callback: The callback function to execute when data
            is read.
            device: The device mountpoint/endpoint.
            baudrate: The baudrate of the serial connection.
            amrate: The Active Messaging rate configured for the
            application running on the TinyOS device.
            pkt_type: The TinyOS packet type. This is application
            specific. The most common type is an Oscilloscope
            packet.
        '''
        super().__init__(self, callback, device, baudrate, ltype=T_TINYOS)
            
        _amrate = threading.local()
        _amrate = amrate
        
        _pkt_type = threading.local()
        _pkt_type = pkt_type
        
        
    def amrate(self):
        '''
        Gets the Active Messaging rate of the appliication running
        on the device.
        '''
        return self._amrate
        
        
    def packet_type(self):
        '''
        Gets the packet type used by the listener.
        '''
        return self._pkt_type
    
    
    def listen(self):
        '''
        Overrides the listen() method in the base class to read in a
        TinyOS packet.
        '''
        # read in the packet
        p = am.read()
        # check if there was a packet and we have an AM rate for it
        if p and p.type == LISTENER.AM_RATES[self._amrate]:
            msg = self._pkt_type(p.data)
            callback(msg)


        
